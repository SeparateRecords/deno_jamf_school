#!/usr/bin/env deno --allow-read --allow-write

import * as flags from "./deps/std_flags.ts";
import * as glob from "./deps/std_fs_expand_glob.ts";
import * as log from "./deps/std_log.ts";
import * as path from "./deps/std_path.ts";
import * as permissions from "./deps/std_permissions.ts";
import * as z from "./deps/zod.ts";
import { readAll } from "./deps/std_io_util.ts";
import { colorize } from "./deps/colorize.ts";
import { substitute, SubstituteOptions } from "./deps/substitute.ts";
import { closest } from "./deps/fastest_levenshtein.ts";

// dprint-ignore
const helpText = colorize`
${["INTRODUCTION:", "bold"]}

Replace variables in *.tpl files and write the result to another file, dropping
the .tpl extension. Variables follow basic shell syntax: ${["$VAR", "italic"]} or ${["\${VAR}", "italic"]}

Directories will be searched recursively for files matching *.tpl.md.
Searching and rendering are concurrent.

All variables and settings are piped in as UTF-8 JSON via stdin. How you get
this data into the program is up to you. It can be generated by a script or
stored in a JSON file. As long as it goes over stdin, you're good.
See the ${["USAGE EXAMPLES", "underline"]} section below for some ideas.


${["OPTIONS:", "bold"]}

  -h, --help                Show this message.

      --dry                 Run everything as normal, but don't write the files.

      --log-level <level>   Set logger verbosity. Either "debug" or "info".


${["JSON STRUCTURE:", "bold"]}

In the top-level object, a "variables" key must be present. It is an object
containing the key/value pairs that will be accessible from variables in the
markdown documents.

  {
    "variables": {
      "key": "value"
    }
  }

An optional "settings" key may be present, containing any number of the
settings below. All settings are optional. See the ${["USAGE EXAMPLES", "underline"]} section.

${["SETTINGS:", "bold"]}

The following settings allow you to override or add behaviour. None of these
settings and required. If the setting doesn't have a default, it simply won't
do the thing if you don't set it.

${["unhideHiddenFiles", "underline"]}: ${["boolean", "italic"]}  [default: false]
  Remove a leading dot from file names.

${["contentPrefix", "underline"]}: ${["string", "italic"]}
  Insert this string first, followed by two blank lines. Variable substitution
  syntax is supported in this string. The following variables can be used:
  - 'name': The name of the source file.
  - 'eol': The kind of line-ending for that file.

${["replaceLeadingTabs", "underline"]}: ${["string", "italic"]}
  Replace leading tabs with this string. It will be repeated for each
  consecutive tab.

${["allowPercentVariables", "underline"]}: ${["boolean", "italic"]}  [default: false]
  Specify whether %VARIABLE% syntax is recognised.

${["excludePaths", "underline"]}: ${["string[]", "italic"]}
  A list of paths to exclude from searching. These paths may be directories or
  files. The paths will be resolved from the current working directory (CWD)
  and may include glob patterns.
  You may want to add "**/node_modules" to this array.

${["lineEnding", "underline"]}: ${['"lf" | "crlf" | "auto"', "italic"]}  [default: "auto"]
  Replace line endings with \\n or \\r\\n, or detect the EOL sequence based on
  the first line ending in the file. Line endings will only be replaced if the
  detected line ending doesn't match the override.

${["inputFileSuffix", "underline"]}: ${["string", "italic"]}  [default: ".tpl"]
  Searches recursively for all files that end with this suffix.
  This must not contain any glob characters such as * or ?.

${["outputFileSuffix", "underline"]}: ${["string", "italic"]}  [default: ""]
  The input suffix will be replaced with this string.
  This must not contain any glob characters such as * or ?.

${["root", "underline"]}: ${["string", "italic"]}  [default: <cwd>]
  The root directory, from which all recursive searches will be started. This
  path should be absolute, as relative paths are relative to your CWD. If this
  option is set, it is assumed to be a valid path - it is never checked.


${["NOTES:", "bold"]}

* You can escape a variable with a double dollar sign, eg. $$VAR or $\${VAR}

* Due to limitations with deno_substitute, you cannot have "=" in a key.

* Execution times are debug-logged. Passing '--allow-hrtime' will increase
  the accuracy of these measurements.


${["USAGE EXAMPLES:", "bold"]}

The script requires '--allow-read=.' and '--allow-write=.' but the flags have
been omitted from the examples for brevity. The script will fail without them.
Because stdin is a pipe, not a terminal, '--prompt' cannot be used.

  ${["$", "dim"]} "cat" tpl.json
  {
    "settings": {
      "excludePaths": ["**/node_modules"]
    },
    "variables": {
      "VERSION": "1.0.0",
      "URL": "https://example.com"
    }
  }

${["Using a JSON file with cat(1):", "underline"]}

  ${["$", "dim"]} cat tpl.json | deno run ./scripts/render.ts

${["Using a JSON file and redirection:", "underline"]}

  ${["$", "dim"]} deno run ./scripts/render.ts < tpl.json

${["With PowerShell on Windows:", "underline"]}

  ${["PS C:\\>", "dim"]} Get-Content tpl.json | deno run .\\scripts\\render.ts

${["Using a script:", "underline"]}

  This example gives the render script access to all environment variables,
  and sets the search root to the directory containing the script.

  ${["$", "dim"]} cat tpl.js
  console.log(JSON.stringify({
    settings: {
      root: new URL(".", import.meta.url).pathname,
    },
    variables: {
      ...Deno.env.toObject(),
    },
  }));

  ${["$", "dim"]} deno run --allow-env tpl.js | deno run ./scripts/render.ts

`.trimStart()

//
// 0. Argument parsing and help
//

const { help, dry, "log-level": logLevelArg } = flags.parse(Deno.args, {
	boolean: ["help", "dry"],
	string: ["log-level"],
	alias: { help: ["h"] },
});

if (help || Deno.isatty(Deno.stdin.rid)) {
	console.log(helpText);
	Deno.exit(0);
}

//
// 1. Set up logging
//

/** TS 4.1 added string manipulation types! */
// @ts-ignore since `Uppercase` is implemented with String.toUpperCase
const toUpperConst = <T extends string>(s: T): Uppercase<T> => s.toUpperCase();

{
	const parsedLogLevel = z.union([
		z.literal("info"),
		z.literal("debug"),
	]).transform(toUpperConst).safeParse(logLevelArg);

	const logLevel = parsedLogLevel.success ? toUpperConst(parsedLogLevel.data) : "ERROR";

	await log.setup({
		loggers: {
			tpl: {
				level: logLevel,
				handlers: ["console"],
			},
		},
		handlers: {
			console: new log.handlers.ConsoleHandler("DEBUG", {
				formatter: (record) => {
					const { loggerName, levelName, msg } = record;
					return `${loggerName} ${levelName.toLowerCase()}: ${msg}`;
				},
			}),
		},
	});
}

const logger = log.getLogger("tpl");

type Timer = () => () => number;

/**
 * Get a function that, when called, returns the number of milliseconds since
 * the first function was created. More accurate with --allow-hrtime
 */
const timer: Timer = (start = performance.now()) => () => performance.now() - start;

const timeFinish = timer();
addEventListener("unload", () => {
	logger.info(`Finished running in ${timeFinish()} ms`);
});

//
// 2. Parse and validate the input, and ensure the correct permissions are granted
//

const validateSuffix = (s: string) => /^[A-Za-z0-9_\-\.\$]*$/.test(s);
const suffixmsg = {
	message: "Suffixes may not contain characters that could be used for globbing.",
};

const schema = z.object({
	settings: z.optional(z.object({
		replaceLeadingTabs: z.optional(z.string()),
		unhideHiddenFiles: z.optional(z.boolean()),
		contentPrefix: z.optional(z.string()),
		lineEnding: z.optional(z.union([
			z.literal("lf"),
			z.literal("crlf"),
			z.literal("auto"),
		])),
		inputFileSuffix: z.optional(z.string().refine(validateSuffix, suffixmsg)),
		outputFileSuffix: z.optional(z.string().refine(validateSuffix, suffixmsg)),
		excludePaths: z.optional(z.array(z.string())),
		allowPercentVariables: z.optional(z.boolean()),
		root: z.optional(z.string()),
	})),
	variables: z.record(z.string()),
}).strict();

export type Schema = z.infer<typeof schema>;

const timeStdin = timer();
const stdin = new TextDecoder().decode(await readAll(Deno.stdin));
logger.debug(`Finished reading stdin in ${timeStdin()} ms`);

const timeParse = timer();

let inputJSON;
try {
	inputJSON = JSON.parse(stdin);
} catch (error: unknown) {
	if (error instanceof SyntaxError) {
		logger.critical(`Invalid JSON input: ${stdin}`);
		Deno.exit(1);
	}
	throw error;
}

let userConfig;
try {
	userConfig = schema.parse(inputJSON);
} catch (error: unknown) {
	if (error instanceof z.ZodError) {
		// Zod parses completely before throwing, makes it super easy to log a
		// complete list of errors.
		for (const issue of error.issues) {
			const kind = issue.code;
			const where = issue.path.join(".") || "root";
			logger.critical(`${kind} at ${where}: ${issue.message}`);
			Deno.exit(1);
		}
	}
	throw error;
}
logger.debug(`Finished parsing and validating configuration in ${timeParse()} ms`);

//
// 3. Extract the options and variables
//

const {
	replaceLeadingTabs = "",
	unhideHiddenFiles = false,
	lineEnding = "auto",
	contentPrefix = false,
	inputFileSuffix = ".tpl",
	outputFileSuffix = "",
	excludePaths = [],
	allowPercentVariables = false,
	root = null,
} = userConfig.settings ?? {};

// Since stdin isn't a TTY, grantOrThrow can't prompt and will just throw.
await permissions.grantOrThrow(
	{ name: "read", path: root ?? "." },
	{ name: "write", path: root ?? "." },
);

if (root !== null) {
	Deno.chdir(root);
}

/** A map of all variables that aren't configuration. */
const vars = new Map(Object.entries(userConfig.variables));

//
// 4. Setup for searching for files
//

// This won't change and I don't want to call Deno.cwd() for each rmcwd()
const cwd = Deno.cwd();

/** Remove the current working directory from the path. */
const rmcwd = (p: string) => p.slice(cwd.length + 1);

/** Replace the input file suffix with the output file suffix. */
const resuffix = (p: string) =>
	p.slice(0, p.length - inputFileSuffix.length) + outputFileSuffix;

/** Best-guess at what the file EOL is based on the first line break. */
const guessEOL = (s: string) => s[s.indexOf("\n") - 1] === "\r" ? "\r\n" : "\n";

// This may get logging later
const getVar = (key: string) => {
	const value = vars.get(key);
	if (value === undefined) {
		const all = [...vars.keys()];
		const match = closest(key, all);
		console.error(
			`Attempted to access an undefined variable: ${key} (did you mean ${match}?)`,
		);
		Deno.exit(1);
	}
	return value;
};

const substituteOptions: SubstituteOptions = {
	percent: allowPercentVariables,
};

//
// 5. Searching for files
//

const timeSearching = timer();
logger.debug("Searching for files matching **/*" + inputFileSuffix);

const searchIterator = glob.expandGlob("**/*" + inputFileSuffix, {
	globstar: true,
	includeDirs: false,
	caseInsensitive: false,
	exclude: excludePaths,
	root: cwd,
});

for await (const entry of searchIterator) {
	// must be done in an async IIFE otherwise it would be blocking.
	(async (entry) => {
		const relativePath = rmcwd(entry.path);
		const info = (text: string) => logger.info(`${relativePath}: ${text}`);
		const debug = (text: string) => logger.debug(`${relativePath}: ${text}`);
		const warning = (text: string) => logger.warning(`${relativePath}: ${text}`);

		const timeFile = timer();

		info("Matched");

		if (!entry.isFile) {
			warning("Not a file, skipping");
			return; // IIFE, can't use `continue`
		}

		debug("Reading file");
		// This variable will be mutated as it's changed by substitution and
		// postprocessing (tab replacement, text insertion, etc)
		let content = await Deno.readTextFile(entry.path);

		const fileEOL = guessEOL(content);
		const eol2 = fileEOL + fileEOL;
		debug(`Line ending is probably ${fileEOL === "\n" ? "lf" : "crlf"}`);

		debug("Substituting content");
		content = substitute(content, getVar, substituteOptions);

		if (replaceLeadingTabs) {
			logger.debug(`${rmcwd(entry.path)}: Replacing leading tabs`);
			content = content.replaceAll(
				/^\t+/gm,
				(match) => replaceLeadingTabs.repeat(match.length),
			);
		}

		if (contentPrefix) {
			debug("Inserting prefix");
			const prefixVars = new Map([
				["name", entry.name],
				["eol", fileEOL],
			]);
			const subbedPrefix = substitute(
				contentPrefix,
				(name: string) => prefixVars.get(name),
				substituteOptions,
			);
			content = `${subbedPrefix}${eol2}${content}`;
		}

		// Only need to change file EOL if explicitly set, otherwise the correct
		// EOL will have been used where appropriate. This will also only change
		// the line ending if the file uses a different line ending.
		if (lineEnding !== "auto") {
			const desiredEOL = lineEnding === "crlf" ? "\r\n" : "\n";
			if (fileEOL !== desiredEOL) {
				debug(`Replacing line endings with ${lineEnding}`);
				content = content.replaceAll(fileEOL, desiredEOL);
			}
		}

		// Remove the template extension by slicing up to it, since we know
		// this path must end with it.
		let outPath = resuffix(entry.path);

		// Just remove the first character of the file name
		const name = path.basename(outPath);
		if (unhideHiddenFiles && name.startsWith(".")) {
			outPath = path.join(path.dirname(outPath), name.slice(1));
		}

		if (dry) {
			info(`Not writing to ${rmcwd(outPath)} due to --dry`);
		} else {
			info(`Writing to ${rmcwd(outPath)}`);
			await Deno.writeTextFile(outPath, content);
		}

		debug(`Took ${timeFile()} ms`);
	})(entry);
}

logger.debug(`Finished searching for files in ${timeSearching()} ms`);
